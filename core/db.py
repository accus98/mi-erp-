import sqlite3
import os

class Database:
    _connection = None

    @classmethod
    def connect(cls):
        """
        Returns a Singleton SQLite connection.
        """
        if not cls._connection:
            db_path = os.path.join(os.getcwd(), 'nexo.db')
            # print(f"ðŸ”Œ Using SQLite: {db_path}")
            
            # check_same_thread=False allowed for Dev server (single process, threaded)
            cls._connection = sqlite3.connect(db_path, check_same_thread=False)
            cls._connection.row_factory = sqlite3.Row 
            cls._connection.execute("PRAGMA foreign_keys = ON")
            
        return cls._connection

    @classmethod
    def release(cls, conn):
        # No-op for Singleton SQLite
        pass

    @classmethod
    def close_all(cls):
        if cls._connection:
            cls._connection.close()
            cls._connection = None

    @classmethod
    def cursor(cls, conn):
        return CursorWrapper(conn.cursor())

import uuid

class CursorWrapper:
    def __init__(self, real_cursor):
        self._cursor = real_cursor

    def __getattr__(self, name):
        return getattr(self._cursor, name)

    def savepoint(self):
        return Savepoint(self._cursor)

class Savepoint:
    def __init__(self, cursor):
        self.cursor = cursor
        self.sp_name = f"sp_{uuid.uuid4().hex}"

    def __enter__(self):
        self.cursor.execute(f"SAVEPOINT {self.sp_name}")
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type:
            self.cursor.execute(f"ROLLBACK TO {self.sp_name}")
        else:
            self.cursor.execute(f"RELEASE {self.sp_name}")

    @classmethod
    def create_table(cls, cr, table_name, columns, constraints):
        # SQLite Adaptation
        # columns is list of strings: '"name" VARCHAR'
        
        # 1. Sanitize Columns for SQLite
        safe_cols = []
        for col in columns:
            # Postgres Identity -> SQLite Autoincrement
            if "GENERATED BY DEFAULT AS IDENTITY" in col:
                col = col.replace("GENERATED BY DEFAULT AS IDENTITY", "AUTOINCREMENT")
            safe_cols.append(col)
            
        cols_def = ", ".join(safe_cols)
        if constraints:
            cols_def += ", " + ", ".join(constraints)
        
        query = f'CREATE TABLE IF NOT EXISTS "{table_name}" ({cols_def})'
        try:
            cr.execute(query)
        except Exception as e:
            print(f"Error creating table {table_name}: {e}")
            raise e

    @classmethod
    def create_pivot_table(cls, cr, table_name, col1, ref1, col2, ref2):
        query = f"""
        CREATE TABLE IF NOT EXISTS "{table_name}" (
            "{col1}" INTEGER REFERENCES "{ref1}" (id) ON DELETE CASCADE,
            "{col2}" INTEGER REFERENCES "{ref2}" (id) ON DELETE CASCADE,
            UNIQUE ("{col1}", "{col2}")
        )
        """
        try:
            cr.execute(query)
        except Exception as e:
            print(f"Error creating pivot {table_name}: {e}")
            raise e
